"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Authenticator = void 0;
const server_runtime_1 = require("@remix-run/server-runtime");
class Authenticator {
    /**
     * Create a new instance of the Authenticator.
     *
     * It receives a instance of the SessionStorage. This session storage could
     * be created using any method exported by Remix, this includes:
     * - `createSessionStorage`
     * - `createFileSystemSessionStorage`
     * - `createCookieSessionStorage`
     * - `createMemorySessionStorage`
     *
     * It optionally receives an object with extra options. The supported options
     * are:
     * - `sessionKey`: The key used to store and red the user in the session storage.
     * @example
     * import { sessionStorage } from "./session.server";
     * let authenticator = new Authenticator(sessionStorage);
     * @example
     * import { sessionStorage } from "./session.server";
     * let authenticator = new Authenticator(sessionStorage, {
     *   sessionKey: "token",
     * });
     */
    constructor(sessionStorage, options = {}) {
        var _a;
        this.sessionStorage = sessionStorage;
        /**
         * A map of the configured strategies, the key is the name of the strategy
         * @private
         */
        this.strategies = new Map();
        this.sessionKey = options.sessionKey || "user";
        this.sessionErrorKey = options.sessionErrorKey || "auth:error";
        this.sessionStrategyKey = options.sessionStrategyKey || "strategy";
        this.throwOnError = (_a = options.throwOnError) !== null && _a !== void 0 ? _a : false;
    }
    /**
     * Call this method with the Strategy, the optional name allows you to setup
     * the same strategy multiple times with different names.
     * It returns the Authenticator instance for concatenation.
     * @example
     * authenticator
     *  .use(new SomeStrategy({}, (user) => Promise.resolve(user)))
     *  .use(new SomeStrategy({}, (user) => Promise.resolve(user)), "another");
     */
    use(strategy, name) {
        this.strategies.set(name !== null && name !== void 0 ? name : strategy.name, strategy);
        return this;
    }
    /**
     * Call this method with the name of the strategy you want to remove.
     * It returns the Authenticator instance for concatenation.
     * @example
     * authenticator.unuse("another").unuse("some");
     */
    unuse(name) {
        this.strategies.delete(name);
        return this;
    }
    /**
     * Call this to authenticate a request using some strategy. You pass the name
     * of the strategy you want to use and the request to authenticate.
     * The optional callback allows you to do something with the user object
     * before returning a new Response. In case it's not provided the strategy
     * will return a new Response and set the user to the session.
     * @example
     * let action: ActionFunction = async ({ request }) => {
     *   let user = await authenticator.authenticate("some", request);
     * };
     * @example
     * let action: ActionFunction = ({ request }) => {
     *   return authenticator.authenticate("some", request, {
     *     successRedirect: "/private",
     *     failureRedirect: "/login",
     *   });
     * };
     */
    authenticate(strategy, request, options = {}) {
        const strategyObj = this.strategies.get(strategy);
        if (!strategyObj)
            throw new Error(`Strategy ${strategy} not found.`);
        return strategyObj.authenticate(request.clone(), this.sessionStorage, {
            throwOnError: this.throwOnError,
            ...options,
            sessionKey: this.sessionKey,
            sessionErrorKey: this.sessionErrorKey,
            sessionStrategyKey: this.sessionStrategyKey,
        });
    }
    async isAuthenticated(request, options = {}) {
        var _a;
        let session = await this.sessionStorage.getSession(request.headers.get("Cookie"));
        let user = (_a = session.get(this.sessionKey)) !== null && _a !== void 0 ? _a : null;
        if (user) {
            if (options.successRedirect)
                throw server_runtime_1.redirect(options.successRedirect);
            else
                return user;
        }
        if (options.failureRedirect)
            throw server_runtime_1.redirect(options.failureRedirect);
        else
            return null;
    }
    /**
     * Destroy the user session throw a redirect to another URL.
     * @example
     * let action: ActionFunction = async ({ request }) => {
     *   await authenticator.logout(request, { redirectTo: "/login" });
     * }
     */
    async logout(request, options) {
        let session = await this.sessionStorage.getSession(request.headers.get("Cookie"));
        throw server_runtime_1.redirect(options.redirectTo, {
            headers: {
                "Set-Cookie": await this.sessionStorage.destroySession(session),
            },
        });
    }
}
exports.Authenticator = Authenticator;
