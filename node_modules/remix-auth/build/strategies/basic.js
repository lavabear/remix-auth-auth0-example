"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BasicStrategy = void 0;
const server_runtime_1 = require("@remix-run/server-runtime");
const strategy_1 = require("../strategy");
/**
 * The HTTP Basic authentication strategy authenticates requests based on
 * userId and password credentials contained in the `Authorization` header
 * field.
 *
 * Applications must supply a `verify` callback which accepts `userId` and
 * `password` credentials, and then return supplying a `user`, which should
 * raise an error if the credentials are not valid or an exception ocurred.
 *
 * Optionally, `options` can be used to change the authentication realm.
 *
 * Options:
 * - `realm`  authentication realm, defaults to "Users"
 *
 * @example
 * authenticator.use(new BasicStrategy(
 *   { realm: "Users" },
 *   (userId, password) => {
 *     return User.findOne({ username: userId, password: password });
 *   }
 * ));
 *
 * For further details on HTTP Basic authentication, refer to [RFC 2617: HTTP Authentication: Basic and Digest Access Authentication](http://tools.ietf.org/html/rfc2617)
 */
class BasicStrategy extends strategy_1.Strategy {
    constructor(options, verify) {
        super(verify);
        this.name = "basic";
        this.realm = "Users";
        this.realm = options.realm || this.realm;
    }
    async authenticate(request) {
        let authorization = request.headers.get("Authorization");
        if (!authorization) {
            throw server_runtime_1.json({ message: "Missing Authorization header." }, { status: 401, headers: this.headers() });
        }
        if (!authorization.includes(" ")) {
            throw server_runtime_1.json({ message: "Invalid Authorization value." }, { status: 401, headers: this.headers() });
        }
        let [scheme, credentials] = authorization.split(" ");
        if (!/basic/i.test(scheme)) {
            throw server_runtime_1.json({ message: "Invalid Authorization scheme." }, { status: 401, headers: this.headers() });
        }
        let [userId, password] = Buffer.from(credentials, "base64")
            .toString()
            .split(":");
        if (!userId || !password) {
            throw server_runtime_1.json({ message: "Missing user ID or password." }, { status: 401, headers: this.headers() });
        }
        try {
            return await this.verify({ userId, password });
        }
        catch (error) {
            let message = error.message;
            throw server_runtime_1.json({ message }, { status: 401, headers: this.headers() });
        }
    }
    headers() {
        return {
            "WWW-Authenticate": this.challenge(),
        };
    }
    challenge() {
        return `Basic realm="${this.realm}"`;
    }
}
exports.BasicStrategy = BasicStrategy;
